#!/usr/bin/env bash
set -euo pipefail

# Inputs (comma or newline separated)
# ALLOW_DOMAINS:  e.g. ".github.com,api.github.com,.pypi.org"
# ALLOW_CIDRS:    e.g. "1.2.3.0/24, 2606:2800:220:1:248:1893:25c8:1946/128"
# ALLOW_PORTS:    e.g. "443,80,9418"  (optional, defaults to 80+443)
# BLOCK_BY_DEFAULT: "true"|"false" (default: true)
# DISABLE_CACHE: "true"|"false" (default: true)

ALLOW_DOMAINS="${ALLOW_DOMAINS:-}"
ALLOW_CIDRS="${ALLOW_CIDRS:-}"
ALLOW_PORTS="${ALLOW_PORTS:-}"
BLOCK_BY_DEFAULT="${BLOCK_BY_DEFAULT:-true}"
DISABLE_CACHE="${DISABLE_CACHE:-true}"

nl_to_space() {
  # turn newlines/commas into single spaces
  echo "$1" | tr '\n,' '  ' | xargs || true
}

DOMAINS="$(nl_to_space "$ALLOW_DOMAINS")"
CIDRS="$(nl_to_space "$ALLOW_CIDRS")"
PORTS="$(nl_to_space "${ALLOW_PORTS:-80 443}")"

# Build ACL snippets
DOMAINS_ACL=""
SNI_ACL=""
if [ -n "$DOMAINS" ]; then
  # split into tokens and emit multiple lines to keep squid happy with long lists
  for d in $DOMAINS; do
    DOMAINS_ACL+="acl allowed_domains dstdomain ${d}\n"
    SNI_ACL+="acl allowed_sni ssl::server_name ${d}\n"
  done
fi

CIDRS_ACL=""
if [ -n "$CIDRS" ]; then
  for c in $CIDRS; do
    CIDRS_ACL+="acl allowed_cidrs dst ${c}\n"
  done
fi

PORTS_ACL=""
if [ -n "$PORTS" ]; then
  PORTS_ACL="acl allowed_ports port ${PORTS}"
fi

# Access rules
# - Allow HTTPS CONNECT only if SNI or dest IP/CIDR is whitelisted AND port is allowed
# - Allow HTTP if domain/cidr + port allowed
# - If BLOCK_BY_DEFAULT=false, append 'allow all' at the end (not recommended)
ALLOW_BLOCK_RULES=$(cat <<'EOF'
# Methods
acl CONNECT method CONNECT

# CONNECT → only SNI or CIDR + allowed ports
http_access allow CONNECT allowed_sni allowed_ports
http_access allow CONNECT allowed_cidrs allowed_ports

# Plain HTTP → domain or CIDR + allowed ports
http_access allow allowed_domains allowed_ports
http_access allow allowed_cidrs allowed_ports

# Deny everything else by default
http_access deny all
EOF
)

if [ "${BLOCK_BY_DEFAULT}" != "true" ]; then
  ALLOW_BLOCK_RULES=$(printf "%s\n%s\n" "$ALLOW_BLOCK_RULES" "http_access allow all")
fi

# Cache policy
CACHE_SECTION=""
if [ "${DISABLE_CACHE}" = "true" ]; then
  CACHE_SECTION=$(cat <<'EOF'
# Disable caching (pure forward proxy)
cache deny all
cache_mem 0 MB
maximum_object_size 0 KB
EOF
)
fi

# Render /etc/squid/squid.conf
cat >/etc/squid/squid.conf <<EOF
# Generated by 10-gen-conf.sh

http_port 3128

# Prefer IPv4 first to avoid IPv6 oddities in containers
dns_v4_first on

# Privacy-ish
via off
forwarded_for delete

# Logs
access_log stdio:${SQUID_ACCESS_LOG:-/var/log/squid/access.log}
cache_log ${SQUID_CACHE_LOG:-/var/log/squid/cache.log}

${CACHE_SECTION}

# ---- ACLs (generated) ----
${DOMAINS_ACL}
${SNI_ACL}
${CIDRS_ACL}
${PORTS_ACL}

# ---- Policy ----
${ALLOW_BLOCK_RULES}

# Be explicit: safe request/response sizes
request_body_max_size 64 MB
reply_body_max_size 0 allow all
EOF

# Let upstream entrypoint run (handles permissions, init, then exec)
# The official squid image uses /docker-entrypoint.sh and sources /docker-entrypoint.d/*
# so we simply exit and let it continue.
:
